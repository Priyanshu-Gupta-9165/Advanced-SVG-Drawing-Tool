<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional SVG Drawing Tool | Priyanshu Gupta</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #333;
        }
        
        .container {
            width: 100%;
            max-width: 1400px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        header {
            background: linear-gradient(90deg, #4b6cb7 0%, #182848 100%);
            color: white;
            padding: 20px;
            text-align: center;
            position: relative;
        }
        
        h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-weight: 300;
            opacity: 0.9;
        }
        
        .designer-name {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 1.1rem;
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: 500;
        }
        
        .main-content {
            display: flex;
            flex: 1;
        }
        
        .toolbar {
            width: 280px;
            padding: 20px;
            background-color: #f8f9fa;
            border-right: 1px solid #e9ecef;
            display: flex;
            flex-direction: column;
            gap: 25px;
            overflow-y: auto;
        }
        
        .tool-group {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            padding: 15px;
        }
        
        .tool-group h3 {
            font-size: 1rem;
            color: #495057;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .tool-group h3 i {
            font-size: 1.1rem;
        }
        
        .shape-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        
        .shape-btn {
            padding: 12px 5px;
            background-color: #f1f3f5;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }
        
        .shape-btn:hover {
            background-color: #e9ecef;
            transform: translateY(-2px);
        }
        
        .shape-btn.active {
            background-color: #4b6cb7;
            color: white;
            border-color: #3a5a9b;
        }
        
        .shape-btn i {
            font-size: 1.4rem;
        }
        
        .shape-btn span {
            font-size: 0.8rem;
        }
        
        .color-picker {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .color-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .color-item label {
            font-size: 0.9rem;
            color: #6c757d;
        }
        
        input[type="color"] {
            width: 40px;
            height: 40px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            cursor: pointer;
            padding: 0;
            background: none;
        }
        
        input[type="range"] {
            width: 100%;
        }
        
        .value-display {
            font-size: 0.9rem;
            color: #6c757d;
            text-align: center;
            margin-top: 5px;
        }
        
        .action-btn {
            padding: 12px 15px;
            background-color: #4b6cb7;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            margin-bottom: 10px;
        }
        
        .action-btn:hover {
            background-color: #3a5a9b;
        }
        
        #clear-btn {
            background-color: #dc3545;
        }
        
        #clear-btn:hover {
            background-color: #bd2130;
        }
        
        .drawing-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        .drawing-header {
            padding: 15px 20px;
            background-color: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .coordinates {
            font-size: 0.9rem;
            color: #6c757d;
        }
        
        .drawing-area {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        #svg-canvas {
            width: 100%;
            height: 100%;
            background-color: white;
            cursor: crosshair;
        }
        
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background-image: 
                linear-gradient(rgba(0, 0, 0, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 0, 0, 0.05) 1px, transparent 1px);
            background-size: 20px 20px;
        }
        
        .instructions {
            padding: 20px;
            background-color: #f8f9fa;
            border-top: 1px solid #e9ecef;
        }
        
        .instructions h3 {
            margin-bottom: 10px;
            color: #495057;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .instructions ul {
            padding-left: 20px;
            color: #6c757d;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 10px;
        }
        
        .instructions li {
            margin-bottom: 8px;
        }
        
        footer {
            text-align: center;
            margin-top: 20px;
            color: #6c757d;
            font-size: 0.9rem;
        }
        
        /* Transformation controls */
        .transform-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        
        .transform-input {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .transform-input label {
            font-size: 0.8rem;
            color: #6c757d;
        }
        
        .transform-input input {
            padding: 8px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
        }
        
        /* Selection style */
        .selected {
            outline: 2px dashed #4b6cb7;
            outline-offset: 2px;
        }
        
        /* Responsive adjustments */
        @media (max-width: 992px) {
            .main-content {
                flex-direction: column;
            }
            
            .toolbar {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #e9ecef;
            }
            
            .drawing-area {
                height: 500px;
            }
            
            .instructions ul {
                grid-template-columns: 1fr;
            }
            
            .designer-name {
                position: relative;
                top: 0;
                right: 0;
                margin-top: 10px;
            }
        }
        
        @media (max-width: 576px) {
            .shape-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .transform-controls {
                grid-template-columns: 1fr;
            }
        }
        
        /* Toast notification */
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 12px 20px;
            border-radius: 6px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
        }
        
        .toast.show {
            opacity: 1;
        }
        
        /* Help modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background-color: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .close-btn {
            font-size: 1.5rem;
            cursor: pointer;
            background: none;
            border: none;
        }
        
        /* Shape preview */
        .shape-preview {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 60px;
            margin-top: 10px;
            border: 1px dashed #dee2e6;
            border-radius: 6px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Professional SVG Drawing Tool</h1>
            <p class="subtitle">Create and manipulate vector shapes with precision</p>
            <div class="designer-name">Designed by Priyanshu Gupta</div>
        </header>
        
        <div class="main-content">
            <div class="toolbar">
                <div class="tool-group">
                    <h3><i class="fas fa-shapes"></i> Shapes</h3>
                    <div class="shape-grid">
                        <button class="shape-btn active" data-shape="rectangle">
                            <i class="fas fa-square"></i>
                            <span>Rectangle</span>
                        </button>
                        <button class="shape-btn" data-shape="circle">
                            <i class="fas fa-circle"></i>
                            <span>Circle</span>
                        </button>
                        <button class="shape-btn" data-shape="line">
                            <i class="fas fa-minus"></i>
                            <span>Line</span>
                        </button>
                        <button class="shape-btn" data-shape="polygon">
                            <i class="fas fa-draw-polygon"></i>
                            <span>Polygon</span>
                        </button>
                        <button class="shape-btn" data-shape="star">
                            <i class="fas fa-star"></i>
                            <span>Star</span>
                        </button>
                        <button class="shape-btn" data-shape="arrow">
                            <i class="fas fa-arrow-right"></i>
                            <span>Arrow</span>
                        </button>
                    </div>
                    <div class="shape-preview" id="shape-preview">
                        <svg width="50" height="50" id="preview-svg"></svg>
                    </div>
                </div>
                
                <div class="tool-group">
                    <h3><i class="fas fa-paint-brush"></i> Styles</h3>
                    <div class="color-picker">
                        <div class="color-item">
                            <label>Stroke:</label>
                            <input type="color" id="stroke-color" value="#000000">
                        </div>
                        <div class="color-item">
                            <label>Fill:</label>
                            <input type="color" id="fill-color" value="#4b6cb7">
                        </div>
                    </div>
                    
                    <div style="margin-top: 15px;">
                        <label>Stroke Width:</label>
                        <input type="range" id="stroke-width" min="1" max="10" value="2">
                        <div class="value-display" id="width-value">2px</div>
                    </div>
                    
                    <div style="margin-top: 15px;">
                        <label>Opacity:</label>
                        <input type="range" id="opacity" min="0.1" max="1" step="0.1" value="1">
                        <div class="value-display" id="opacity-value">100%</div>
                    </div>
                    
                    <div style="margin-top: 15px;">
                        <label>Dash Array:</label>
                        <input type="range" id="dash-array" min="0" max="20" value="0">
                        <div class="value-display" id="dash-value">Solid</div>
                    </div>
                </div>
                
                <div class="tool-group">
                    <h3><i class="fas fa-edit"></i> Transform</h3>
                    <div class="transform-controls">
                        <div class="transform-input">
                            <label>Rotation:</label>
                            <input type="number" id="rotation" min="0" max="360" value="0" placeholder="Degrees">
                        </div>
                        <div class="transform-input">
                            <label>Scale X:</label>
                            <input type="number" id="scaleX" min="0.1" max="5" step="0.1" value="1">
                        </div>
                        <div class="transform-input">
                            <label>Scale Y:</label>
                            <input type="number" id="scaleY" min="0.1" max="5" step="0.1" value="1">
                        </div>
                        <div class="transform-input">
                            <label>Position X:</label>
                            <input type="number" id="posX" value="0" placeholder="X coordinate">
                        </div>
                        <div class="transform-input">
                            <label>Position Y:</label>
                            <input type="number" id="posY" value="0" placeholder="Y coordinate">
                        </div>
                    </div>
                </div>
                
                <div class="tool-group">
                    <h3><i class="fas fa-tools"></i> Actions</h3>
                    <button class="action-btn" id="clear-btn">
                        <i class="fas fa-broom"></i> Clear Canvas
                    </button>
                    <button class="action-btn" id="export-btn">
                        <i class="fas fa-download"></i> Export SVG
                    </button>
                    <button class="action-btn" id="undo-btn">
                        <i class="fas fa-undo"></i> Undo
                    </button>
                    <button class="action-btn" id="redo-btn">
                        <i class="fas fa-redo"></i> Redo
                    </button>
                    <button class="action-btn" id="help-btn">
                        <i class="fas fa-question-circle"></i> Help
                    </button>
                </div>
            </div>
            
            <div class="drawing-container">
                <div class="drawing-header">
                    <div class="coordinates">X: 0, Y: 0</div>
                    <div class="drawing-mode">Current Tool: Rectangle</div>
                </div>
                
                <div class="drawing-area">
                    <svg id="svg-canvas"></svg>
                    <div class="grid-overlay"></div>
                </div>
            </div>
        </div>
        
        <div class="instructions">
            <h3><i class="fas fa-info-circle"></i> How to Use</h3>
            <ul>
                <li>Select a shape from the toolbar</li>
                <li>Click and drag on the canvas to draw the selected shape</li>
                <li>Use transformation controls to rotate, scale, and position shapes</li>
                <li>Customize stroke and fill colors using the color pickers</li>
                <li>Adjust stroke width and opacity with the sliders</li>
                <li>Use Undo/Redo to manage your actions</li>
                <li>Export your creation as an SVG file</li>
            </ul>
        </div>
    </div>
    
    <footer>
        <p>Created by Priyanshu Gupta | Professional SVG Drawing Tool</p>
    </footer>
    
    <div class="toast" id="toast"></div>
    
    <div class="modal" id="help-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Help Guide</h2>
                <button class="close-btn">&times;</button>
            </div>
            <h3>Getting Started</h3>
            <p>Welcome to the Professional SVG Drawing Tool designed by Priyanshu Gupta. This tool allows you to create vector graphics with precision and ease.</p>
            
            <h3>Drawing Shapes</h3>
            <p>Select a shape from the toolbar, then click and drag on the canvas to draw. For polygons, click to place points and double-click to finish.</p>
            
            <h3>Customization</h3>
            <p>Use the style controls to adjust colors, stroke width, opacity, and dash patterns. The transform controls allow you to precisely position, scale, and rotate shapes.</p>
            
            <h3>Exporting</h3>
            <p>Click the Export button to download your creation as an SVG file that can be edited in other vector graphics applications.</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Get DOM elements
            const canvas = document.getElementById('svg-canvas');
            const shapeButtons = document.querySelectorAll('.shape-btn');
            const strokeColor = document.getElementById('stroke-color');
            const fillColor = document.getElementById('fill-color');
            const strokeWidth = document.getElementById('stroke-width');
            const widthValue = document.getElementById('width-value');
            const opacity = document.getElementById('opacity');
            const opacityValue = document.getElementById('opacity-value');
            const dashArray = document.getElementById('dash-array');
            const dashValue = document.getElementById('dash-value');
            const clearBtn = document.getElementById('clear-btn');
            const exportBtn = document.getElementById('export-btn');
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            const helpBtn = document.getElementById('help-btn');
            const coordinates = document.querySelector('.coordinates');
            const drawingMode = document.querySelector('.drawing-mode');
            const toast = document.getElementById('toast');
            const helpModal = document.getElementById('help-modal');
            const closeBtn = document.querySelector('.close-btn');
            const previewSvg = document.getElementById('preview-svg');
            
            // Transformation controls
            const rotation = document.getElementById('rotation');
            const scaleX = document.getElementById('scaleX');
            const scaleY = document.getElementById('scaleY');
            const posX = document.getElementById('posX');
            const posY = document.getElementById('posY');
            
            // Drawing state
            let currentShape = 'rectangle';
            let isDrawing = false;
            let startX, startY;
            let currentElement = null;
            let selectedElement = null;
            let polygons = [];
            let currentPolygon = null;
            let history = [];
            let historyIndex = -1;
            
            // Initialize canvas
            setCanvasSize();
            updateShapePreview();
            
            // Set active shape
            shapeButtons.forEach(button => {
                button.addEventListener('click', function() {
                    shapeButtons.forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    currentShape = this.dataset.shape;
                    drawingMode.textContent = `Current Tool: ${currentShape.charAt(0).toUpperCase() + currentShape.slice(1)}`;
                    updateShapePreview();
                    
                    // If switching to polygon, reset current polygon
                    if (currentShape !== 'polygon') {
                        currentPolygon = null;
                    }
                });
            });
            
            // Update stroke width display
            strokeWidth.addEventListener('input', function() {
                widthValue.textContent = `${this.value}px`;
                if (selectedElement) {
                    selectedElement.setAttribute('stroke-width', this.value);
                    saveState();
                }
                updateShapePreview();
            });
            
            // Update opacity display
            opacity.addEventListener('input', function() {
                opacityValue.textContent = `${Math.round(this.value * 100)}%`;
                if (selectedElement) {
                    selectedElement.setAttribute('opacity', this.value);
                    saveState();
                }
                updateShapePreview();
            });
            
            // Update dash array
            dashArray.addEventListener('input', function() {
                const value = this.value;
                if (value == 0) {
                    dashValue.textContent = "Solid";
                } else {
                    dashValue.textContent = `Dashed: ${value}`;
                }
                
                if (selectedElement) {
                    if (value == 0) {
                        selectedElement.removeAttribute('stroke-dasharray');
                    } else {
                        selectedElement.setAttribute('stroke-dasharray', value);
                    }
                    saveState();
                }
                updateShapePreview();
            });
            
            // Color change events
            strokeColor.addEventListener('input', function() {
                if (selectedElement) {
                    selectedElement.setAttribute('stroke', this.value);
                    saveState();
                }
                updateShapePreview();
            });
            
            fillColor.addEventListener('input', function() {
                if (selectedElement) {
                    selectedElement.setAttribute('fill', this.value);
                    saveState();
                }
                updateShapePreview();
            });
            
            // Transformation events
            rotation.addEventListener('change', applyTransformations);
            scaleX.addEventListener('change', applyTransformations);
            scaleY.addEventListener('change', applyTransformations);
            posX.addEventListener('change', applyTransformations);
            posY.addEventListener('change', applyTransformations);
            
            // Mouse event handlers
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseleave', stopDrawing);
            canvas.addEventListener('click', handleCanvasClick);
            
            // Clear canvas
            clearBtn.addEventListener('click', function() {
                while (canvas.firstChild) {
                    canvas.removeChild(canvas.firstChild);
                }
                polygons = [];
                currentPolygon = null;
                selectedElement = null;
                saveState();
                showToast("Canvas cleared");
            });
            
            // Export SVG
            exportBtn.addEventListener('click', function() {
                const svgData = new XMLSerializer().serializeToString(canvas);
                const blob = new Blob([svgData], {type: 'image/svg+xml'});
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = 'drawing.svg';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showToast("Drawing exported as SVG");
            });
            
            // Undo/Redo functionality
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);
            
            // Help modal
            helpBtn.addEventListener('click', function() {
                helpModal.style.display = 'flex';
            });
            
            closeBtn.addEventListener('click', function() {
                helpModal.style.display = 'none';
            });
            
            window.addEventListener('click', function(e) {
                if (e.target === helpModal) {
                    helpModal.style.display = 'none';
                }
            });
            
            // Initialize with empty state
            saveState();
            
            // Set canvas size based on container
            function setCanvasSize() {
                const drawingArea = document.querySelector('.drawing-area');
                const width = drawingArea.clientWidth;
                const height = drawingArea.clientHeight;
                
                canvas.setAttribute('width', width);
                canvas.setAttribute('height', height);
            }
            
            // Update shape preview
            function updateShapePreview() {
                // Clear preview
                while (previewSvg.firstChild) {
                    previewSvg.removeChild(previewSvg.firstChild);
                }
                
                // Create preview element
                let previewElement;
                const strokeVal = strokeColor.value;
                const fillVal = fillColor.value;
                const strokeWidthVal = strokeWidth.value;
                const opacityVal = opacity.value;
                const dashVal = dashArray.value > 0 ? dashArray.value : null;
                
                switch (currentShape) {
                    case 'rectangle':
                        previewElement = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        previewElement.setAttribute('x', 10);
                        previewElement.setAttribute('y', 10);
                        previewElement.setAttribute('width', 30);
                        previewElement.setAttribute('height', 30);
                        break;
                    case 'circle':
                        previewElement = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        previewElement.setAttribute('cx', 25);
                        previewElement.setAttribute('cy', 25);
                        previewElement.setAttribute('r', 15);
                        break;
                    case 'line':
                        previewElement = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        previewElement.setAttribute('x1', 10);
                        previewElement.setAttribute('y1', 10);
                        previewElement.setAttribute('x2', 40);
                        previewElement.setAttribute('y2', 40);
                        break;
                    case 'polygon':
                        previewElement = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        previewElement.setAttribute('points', '25,5 40,40 10,40');
                        break;
                    case 'star':
                        previewElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        previewElement.setAttribute('d', 'M25,5 L30,20 L45,20 L33,30 L38,45 L25,35 L12,45 L17,30 L5,20 L20,20 Z');
                        break;
                    case 'arrow':
                        previewElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        previewElement.setAttribute('d', 'M10,25 L35,25 M35,25 L28,20 M35,25 L28,30');
                        break;
                }
                
                // Apply styles
                previewElement.setAttribute('stroke', strokeVal);
                previewElement.setAttribute('fill', currentShape !== 'line' ? fillVal : 'none');
                previewElement.setAttribute('stroke-width', strokeWidthVal);
                previewElement.setAttribute('opacity', opacityVal);
                if (dashVal) {
                    previewElement.setAttribute('stroke-dasharray', dashVal);
                }
                
                previewSvg.appendChild(previewElement);
            }
            
            // Handle mouse movement for coordinates and drawing
            function handleMouseMove(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Update coordinates display
                coordinates.textContent = `X: ${Math.round(x)}, Y: ${Math.round(y)}`;
                
                // If drawing, continue drawing
                if (isDrawing) {
                    draw(e);
                }
            }
            
            // Handle canvas click for selecting elements
            function handleCanvasClick(e) {
                if (isDrawing) return; // Skip if we're in the middle of drawing
                
                const elements = document.elementsFromPoint(e.clientX, e.clientY);
                const shape = elements.find(el => el !== canvas && el.parentNode === canvas);
                
                // Deselect if clicking on canvas with no shape
                if (!shape) {
                    if (selectedElement) {
                        selectedElement.classList.remove('selected');
                        selectedElement = null;
                    }
                    return;
                }
                
                // Select the clicked shape
                if (selectedElement) {
                    selectedElement.classList.remove('selected');
                }
                
                selectedElement = shape;
                shape.classList.add('selected');
                
                // Update transformation controls with selected shape's properties
                updateTransformControls(shape);
                
                showToast("Shape selected");
            }
            
            // Update transformation controls based on selected shape
            function updateTransformControls(shape) {
                const transform = shape.getAttribute('transform') || '';
                const translateMatch = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
                const rotateMatch = transform.match(/rotate\(([^)]+)\)/);
                const scaleMatch = transform.match(/scale\(([^,]+),\s*([^)]+)\)/);
                
                if (translateMatch) {
                    posX.value = parseFloat(translateMatch[1]);
                    posY.value = parseFloat(translateMatch[2]);
                } else {
                    posX.value = 0;
                    posY.value = 0;
                }
                
                if (rotateMatch) {
                    rotation.value = parseFloat(rotateMatch[1]);
                } else {
                    rotation.value = 0;
                }
                
                if (scaleMatch) {
                    scaleX.value = parseFloat(scaleMatch[1]);
                    scaleY.value = parseFloat(scaleMatch[2]);
                } else {
                    scaleX.value = 1;
                    scaleY.value = 1;
                }
                
                // Update style controls
                strokeWidth.value = shape.getAttribute('stroke-width') || 2;
                widthValue.textContent = `${strokeWidth.value}px`;
                
                strokeColor.value = rgbToHex(shape.getAttribute('stroke')) || '#000000';
                fillColor.value = rgbToHex(shape.getAttribute('fill')) || '#4b6cb7';
                
                const opacityValue = shape.getAttribute('opacity') || 1;
                opacity.value = opacityValue;
                opacityValue.textContent = `${Math.round(opacityValue * 100)}%`;
                
                const dashValue = shape.getAttribute('stroke-dasharray') || 0;
                dashArray.value = dashValue;
                if (dashValue == 0) {
                    dashValue.textContent = "Solid";
                } else {
                    dashValue.textContent = `Dashed: ${dashValue}`;
                }
            }
            
            // Convert RGB color to hex
            function rgbToHex(rgb) {
                if (!rgb || rgb === 'none') return null;
                
                if (rgb.startsWith('#')) return rgb;
                
                const rgbMatch = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
                if (rgbMatch) {
                    return `#${parseInt(rgbMatch[1]).toString(16).padStart(2, '0')}${parseInt(rgbMatch[2]).toString(16).padStart(2, '0')}${parseInt(rgbMatch[3]).toString(16).padStart(2, '0')}`;
                }
                
                return null;
            }
            
            // Apply transformations to selected element
            function applyTransformations() {
                if (!selectedElement) return;
                
                const tx = posX.value || 0;
                const ty = posY.value || 0;
                const rot = rotation.value || 0;
                const sx = scaleX.value || 1;
                const sy = scaleY.value || 1;
                
                let transform = '';
                
                if (tx != 0 || ty != 0) {
                    transform += `translate(${tx}, ${ty}) `;
                }
                
                if (rot != 0) {
                    transform += `rotate(${rot}) `;
                }
                
                if (sx != 1 || sy != 1) {
                    transform += `scale(${sx}, ${sy})`;
                }
                
                selectedElement.setAttribute('transform', transform.trim());
                saveState();
                
                showToast("Transformation applied");
            }
            
            // Drawing functions
            function startDrawing(e) {
                if (e.target !== canvas) return; // Only start drawing on canvas, not on existing shapes
                
                isDrawing = true;
                const rect = canvas.getBoundingClientRect();
                startX = e.clientX - rect.left;
                startY = e.clientY - rect.top;
                
                if (currentShape === 'polygon') {
                    if (!currentPolygon) {
                        // Start a new polygon
                        currentPolygon = {
                            points: [],
                            element: null
                        };
                        polygons.push(currentPolygon);
                    }
                    
                    // Add point to current polygon
                    currentPolygon.points.push([startX, startY]);
                    
                    // Create or update polygon element
                    if (!currentPolygon.element) {
                        currentPolygon.element = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        canvas.appendChild(currentPolygon.element);
                        applyStyles(currentPolygon.element);
                    }
                    
                    updatePolygonPoints(currentPolygon);
                } else {
                    // Create shape element
                    currentElement = createShapeElement();
                    canvas.appendChild(currentElement);
                }
            }
            
            function draw(e) {
                if (!isDrawing) return;
                
                const rect = canvas.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;
                
                if (currentShape === 'polygon') {
                    // For polygon, we just update the last point temporarily
                    if (currentPolygon && currentPolygon.points.length > 0) {
                        const tempPoints = [...currentPolygon.points];
                        tempPoints.push([currentX, currentY]);
                        updatePolygonPoints({points: tempPoints, element: currentPolygon.element});
                    }
                } else {
                    // Update the shape based on mouse position
                    updateShape(currentElement, currentX, currentY);
                }
            }
            
            function stopDrawing() {
                if (!isDrawing) return;
                
                isDrawing = false;
                
                if (currentShape !== 'polygon') {
                    // Select the newly created shape
                    if (selectedElement) {
                        selectedElement.classList.remove('selected');
                    }
                    selectedElement = currentElement;
                    if (selectedElement) {
                        selectedElement.classList.add('selected');
                        updateTransformControls(selectedElement);
                    }
                    
                    currentElement = null;
                    showToast("Shape created");
                }
                
                saveState();
            }
            
            function createShapeElement() {
                let element;
                
                switch (currentShape) {
                    case 'rectangle':
                        element = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        break;
                    case 'circle':
                        element = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        break;
                    case 'line':
                        element = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        break;
                    case 'star':
                        element = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        break;
                    case 'arrow':
                        element = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        break;
                    default:
                        element = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                }
                
                applyStyles(element);
                return element;
            }
            
            function applyStyles(element) {
                element.setAttribute('stroke', strokeColor.value);
                element.setAttribute('stroke-width', strokeWidth.value);
                element.setAttribute('fill', currentShape !== 'line' ? fillColor.value : 'none');
                element.setAttribute('opacity', opacity.value);
                
                if (dashArray.value > 0) {
                    element.setAttribute('stroke-dasharray', dashArray.value);
                }
            }
            
            function updateShape(element, currentX, currentY) {
                const width = currentX - startX;
                const height = currentY - startY;
                
                switch (currentShape) {
                    case 'rectangle':
                        element.setAttribute('x', Math.min(startX, currentX));
                        element.setAttribute('y', Math.min(startY, currentY));
                        element.setAttribute('width', Math.abs(width));
                        element.setAttribute('height', Math.abs(height));
                        break;
                    case 'circle':
                        const radius = Math.sqrt(width * width + height * height) / 2;
                        element.setAttribute('cx', startX);
                        element.setAttribute('cy', startY);
                        element.setAttribute('r', radius);
                        break;
                    case 'line':
                        element.setAttribute('x1', startX);
                        element.setAttribute('y1', startY);
                        element.setAttribute('x2', currentX);
                        element.setAttribute('y2', currentY);
                        break;
                    case 'star':
                        // Create star shape
                        const points = calculateStarPoints(startX, startY, Math.abs(width), Math.abs(height));
                        element.setAttribute('d', pointsToPath(points));
                        break;
                    case 'arrow':
                        // Create arrow shape
                        const arrowPath = calculateArrowPath(startX, startY, currentX, currentY);
                        element.setAttribute('d', arrowPath);
                        break;
                }
            }
            
            // Calculate points for a star
            function calculateStarPoints(cx, cy, width, height) {
                const outerRadius = Math.max(width, height) / 2;
                const innerRadius = outerRadius * 0.4;
                const points = [];
                
                for (let i = 0; i < 10; i++) {
                    const angle = Math.PI / 5 * i;
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const x = cx + radius * Math.sin(angle);
                    const y = cy - radius * Math.cos(angle);
                    points.push([x, y]);
                }
                
                return points;
            }
            
            // Convert points to SVG path
            function pointsToPath(points) {
                return points.map((point, i) => {
                    return `${i === 0 ? 'M' : 'L'} ${point[0]},${point[1]}`;
                }).join(' ') + ' Z';
            }
            
            // Calculate arrow path
            function calculateArrowPath(startX, startY, endX, endY) {
                const headLength = 15;
                const headWidth = 10;
                
                const angle = Math.atan2(endY - startY, endX - startX);
                
                // Calculate the points for the arrowhead
                const leftX = endX - headLength * Math.cos(angle) + headWidth * Math.sin(angle);
                const leftY = endY - headLength * Math.sin(angle) - headWidth * Math.cos(angle);
                
                const rightX = endX - headLength * Math.cos(angle) - headWidth * Math.sin(angle);
                const rightY = endY - headLength * Math.sin(angle) + headWidth * Math.cos(angle);
                
                return `M ${startX},${startY} L ${endX},${endY} M ${leftX},${leftY} L ${endX},${endY} L ${rightX},${rightY}`;
            }
            
            function updatePolygonPoints(polygon) {
                const pointsString = polygon.points.map(point => point.join(',')).join(' ');
                polygon.element.setAttribute('points', pointsString);
            }
            
            // Double-click to finish polygon
            canvas.addEventListener('dblclick', function() {
                if (currentShape === 'polygon' && currentPolygon) {
                    // Select the finished polygon
                    if (selectedElement) {
                        selectedElement.classList.remove('selected');
                    }
                    selectedElement = currentPolygon.element;
                    selectedElement.classList.add('selected');
                    updateTransformControls(selectedElement);
                    
                    currentPolygon = null;
                    saveState();
                    showToast("Polygon completed");
                }
            });
            
            // Save canvas state for undo/redo
            function saveState() {
                // Remove future states if we're not at the end of history
                if (historyIndex < history.length - 1) {
                    history = history.slice(0, historyIndex + 1);
                }
                
                // Save current state
                history.push(canvas.innerHTML);
                historyIndex++;
                
                // Limit history size
                if (history.length > 50) {
                    history.shift();
                    historyIndex--;
                }
                
                // Update undo/redo buttons
                updateUndoRedoButtons();
            }
            
            // Undo functionality
            function undo() {
                if (historyIndex <= 0) return;
                
                historyIndex--;
                canvas.innerHTML = history[historyIndex];
                
                // Deselect any selected element
                if (selectedElement) {
                    selectedElement.classList.remove('selected');
                    selectedElement = null;
                }
                
                updateUndoRedoButtons();
                showToast("Undo performed");
            }
            
            // Redo functionality
            function redo() {
                if (historyIndex >= history.length - 1) return;
                
                historyIndex++;
                canvas.innerHTML = history[historyIndex];
                
                // Deselect any selected element
                if (selectedElement) {
                    selectedElement.classList.remove('selected');
                    selectedElement = null;
                }
                
                updateUndoRedoButtons();
                showToast("Redo performed");
            }
            
            // Update undo/redo buttons state
            function updateUndoRedoButtons() {
                undoBtn.disabled = historyIndex <= 0;
                redoBtn.disabled = historyIndex >= history.length - 1;
            }
            
            // Show toast notification
            function showToast(message) {
                toast.textContent = message;
                toast.classList.add('show');
                
                setTimeout(function() {
                    toast.classList.remove('show');
                }, 3000);
            }
            
            // Handle window resize
            window.addEventListener('resize', function() {
                setCanvasSize();
                saveState();
            });
        });
    </script>
</body>
</html>
